<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baneling Escape</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #instructions {
            margin-bottom: 10px;
            text-align: center;
            max-width: 600px;
        }
        .terrain-info {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background-color: rgba(255, 255, 255, 0.8);
        }
        #gameInfo {
            margin-top: 10px;
            text-align: center;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
</head>
<body>
    <h1>Baneling Escape</h1>
    <div id="gameInfo">
        Current Scene: <span id="sceneDisplay">1</span> | Terrain: <span id="terrainDisplay">Ice</span> | Death Count: <span id="deathCounter">0</span> 
    </div>

    <script>
        // chooses starting scene
        let sceneCounter = 4;

        let portalBool = false;
        let collide = false;
        let terrainType = 1; // 1 ice, 2 land
        let deathCounter = 0; 
        let lastClick;
        let bane;
        let scene1, scene2, scene3, scene4, scene5, scene6, scene7, scene8, scene9, scene10, scene11, scenes;

        function setup() {
            createCanvas(600, 600);
            lastClick = createVector(0, 0);
            
            // Initialize baneling
            bane = new Baneling(560, 560, 60, 3.75);
            
            // Initialize scenes

            /*
            basicboundary ** 

            new rectObs(0,0,5, 600),
            new rectObs(0, 0, 600, 5),
            new rectObs(0, 595, 600, 5),
            new rectObs(595, 0, 5, 600),
            */

            // 4 -> 1
            scene4 = new Scene(550, 550, []);
            scene4.obstacles = [
                // boundaries
                new rectObs(0,0,5, 600),
                new rectObs(100, 0, 600, 5),
                new rectObs(0, 595, 600, 5),
                new rectObs(595, 0, 5, 280),
                new rectObs(595, 320, 5, 280),
                new rectPortal(0, -5, 100, 5, 1, 50, 570),
                new rectPortal(610, 285, 10, 30, 5, 30, 300),

                // H
                new rectObs(100, 200, 30, 200),
                new rectObs(200, 200, 30, 200),
                new rectObs(130, 300, 70, 30),

                // I
                new rectLand(300, 200, 30, 200),

                // new sizeShift(400, 300, 15, 15, 2)
            ];

            // 1 -> 2
            scene1 = new Scene(37.5, 562.5, []);
            scene1.obstacles = [  
                //interactables
                new rectLand(52.5, 45, 112.5, 60),
                new rectLand(172.5, 487.5, 112.5, 60),
                new rectLand(292.5, 45, 112.5, 60),
                new rectLand(412.5, 487.5, 112.5, 60),
                new rectLand(510, 280, 60,40),

                //boundaries
                new rectPortal(510, -5, 75, 5, 2, 555, 550),
                new rectObs(0,0,5, 600),
                new rectObs(0, 0, 500, 5),
                new rectObs(100, 595, 550, 5),
                new rectObs(595, 0, 5, 280),
                new rectObs(595, 320, 5, 280),
                new rectPortal(610, 285, 10, 30, 9, 30, 300),
                new rectPortal(0, 600, 100, 5, 4, 50, 30),

                //obstacles
                new rectObs(90, 150, 40, 450),
                new rectObs(210, 0, 40, 450),
                new rectObs(330, 150, 40, 450),
                new rectObs(450, 0, 40, 450),
            ];
            
            // 2 -> 3, 4 \
            scene2 = new Scene(562.5, 562.5, []); 
            scene2.obstacles = [

                // boundaries
                new rectObs(0,0,5, 280),
                new rectObs(0,320,5, 280),
                new rectObs(0, 0, 600, 5),
                new rectObs(0, 595, 600, 5),
                new rectObs(595, 0, 5, 280),
                new rectObs(595, 320, 5, 280),
                new rectPortal(605, 285, 10, 30, 6, 30, 300),
                new rectPortal(-15, 285, 10, 30, 3, 570, 300), 

                //obstacles
                new rectObs(465, 150, 40, 130),  
                new rectObs(465, 320, 40, 300),  
                new rectObs(345, 0, 40, 280),    
                new rectObs(345, 320, 40, 130),  
                new rectObs(225, 150, 40, 130), 
                new rectObs(225, 320, 40, 300),  
                new rectObs(105, 0, 40, 280),    
                new rectObs(105, 320, 40, 130),

                new movingObs1(50, 200, 60, 3, 0, 550, 0),
                new movingObs1(50, 400, 60, 2, 0, 550, 0),


                // interactables
                new rectLand(30, 288, 50, 25), 
                new rectLand(525, 288, 50, 25),
                new rectLand(192, 45, 112.5, 60),
                new rectLand(315, 487.5, 112.5, 60),
                new sizeShift(50, 50, 15, 15, 2)
            ]

            scene3 = new Scene(15, 15, []);
            scene3.obstacles = [
                //boundary
                new rectObs(0,0,5, 600),
                new rectObs(0, 0, 600, 5),
                new rectObs(0, 595, 600, 5),
                new rectObs(595, 0, 5, 600),

                new repel(150, 150, 30, 0, 0),
                new repel(225, 225, 30, 0, 0),
                new repel(450, 37.5, 30, 0, 0),
                new repel(75, 450, 30, 0, 0),
                new repel(150, 150, 30, 0, 0),
                new repel(225, 225, 30, 0, 0),
                new repel(450, 37.5, 30, 0, 0),
                new repel(75, 450, 30, 0, 0),
                new planetol(40, 50, 40, 0, 0, 1)
            ];
            
            scene5 = new Scene(50, 300, []);
            scene5.obstacles = [
                new planet(150, 150, 30, 0, 0),
                new planet(225, 225, 30, 0, 0),
                new planet(450, 37.5, 30, 0, 0),
                new planet(75, 450, 30, 0, 0),
                new planet(300, 150, 30, 0, 0),
                new planet(300, 225, 30, 0, 0),
                new planet(500, 37.5, 30, 0, 0),
                new planet(450, 450, 30, 0, 0),
                new planetol(500, 500, 40, 0, 0, 4),

            // boundaries
                new rectObs(0,0,5, 280),
                new rectObs(0,320,5, 280),
                new rectObs(0, 0, 600, 5),
                new rectObs(0, 595, 600, 5),
                new rectObs(595, 0, 5, 600),
                new rectPortal(-20, 285, 10, 30, 4, 570, 300),

            ]
            scene6 = new Scene(50, 300, []);
            scene6.obstacles = [
                // boundaries
                new rectObs(0,0,5, 280),
                new rectObs(0,320,5, 280),
                new rectObs(0, 0, 400, 5),
                new rectObs(450, 0, 150, 5),
                new rectObs(0, 595, 600, 5),
                new rectObs(595, 0, 5, 260),
                new rectObs(595, 340, 5, 280),
                new rectPortal(605, 285, 10, 30, 7, 30, 300),
                new rectPortal(-10, 285, 10, 30, 2, 570, 300),
                new rectPortal(400, -10, 50, 5, 8, 425, 570),

                //level obstacles
                new rectObs(0, 450, 200, 150),
                new rectObs(300, 450, 300, 150),
                new rectObs(0, 0, 400, 150),
                new rectObs(450, 0, 150, 150),

                new movingRectObs(100, 150, 30, 300, 4, 0, 500, 150),

                //level interactables
                new sizeShift(250, 525, 60, 60, 3.75)
            ]
            
            scene7 = new Scene(50,300, []);
            scene7.obstacles = [
            // boundaries
                new rectObs(0,0,5, 270),
                new rectObs(0,340,5, 270),
                new rectObs(0, 0, 600, 5),
                new rectObs(0, 595, 600, 5),
                new rectObs(595, 0, 5, 600),
                new rectPortal(-10, 270, 10, 70, 6, 570, 300),

                //level obstacles
                new rectObs(100, 200, 75, 200),
                new rectObs(325, 200, 75, 200),
                new rectObs(400, 200, 150, 50),
                new rectObs(450, 350, 150, 50),
                new rectObs(0, 400, 200, 200),

                new movingRectObs(100, 0, 30, 200, 4, 0, 500, 0),
                new movingRectObs(200, 400, 30, 200, 2, 0, 570, 0),

                new rectLand(25, 275, 50, 50),
                new rectLand(450, 275, 100, 50),

                //level interactables
                new sizeShift(250, 300, 60, 60, 3.75),
                new sizeShift(550, 100, 15, 15, 2)
            ]
            
            scene8 = new Scene(300,300,[]);
            scene8.obstacles = [

                //boundary
                new rectObs(0,0,5, 600),
                new rectObs(0, 595, 400, 5),
                new rectObs(450, 595, 180, 5),
                new rectObs(0,0,600, 5),
                new rectObs(595, 0, 5, 600),
                new rectPortal(400, 610, 50, 5, 6, 425, 30),

                //obstacles 
                //top right
                new rectObs(370, 400, 10, 200),
                new rectObs(470, 400, 10, 200),
                new rectPortal(380, 410, 90, 10, 8, 420, 150),
                new rectPortal(380, 400, 90, 10, 8, 420, 230),
                //new sizeShift(425, 500, 15, 15, 2),20

                //bottom right
                new rectObs(370, 0, 10, 200),
                new rectObs(470, 0, 10, 50),
                new rectObs(470, 100, 10, 100),
                new rectPortal(380, 180, 90, 10, 8, 420, 450),
                new rectPortal(380, 190, 90, 10, 8, 420, 370),
                new rectObs(200, 300, 400, 5),
                new rectLand(480, 400, 115, 195),

                new sizeShift(540, 500, 60, 60, 3.75),

                //left
                new rectObs(100, 200, 10, 200),
                new rectObs(100, 0, 10, 100),
                // new rectObs(100, 550, 10, 50),
                new movingRectObs(0, 0, 100, 10, 0, 4, 0, 600),

                //center
                new rectLand(110, 5, 260, 295),
                new rectObs(200, 100, 10, 200),
                new rectObs(100, 400, 270, 10),
                new movingObs1(235, 50, 30, 0, 0.8, 250, 280),
                new movingObs1(270, 50, 30, 0, 1.1, 250, 380),
                new movingObs1(305, 50, 30, 0, 1.3, 300, 380),
                new movingObs1(340, 50, 30, 0, 1.5, 300, 380),

                //bottom
                new movingObs1(125, 425, 30, 1.2, 2, 355, 580),
                new Portal(340, 500, 30, 10, 560, 560)
            ]

            scene9 = new Scene(550, 300, []);
            scene9.obstacles = [
                //boundary
                new rectObs(0,0,5, 250),
                new rectObs(0,350, 5, 350),
                new rectObs(0, 0, 600, 5),
                new rectObs(0, 595, 600, 5),
                new rectObs(595, 0, 5, 250),
                new rectObs(595, 350, 5, 250),
                new rectPortal(-10, 270, 10, 60, 1, 570, 300),
                new rectPortal(610, 270, 10, 60, 10, 30, 300),

                //obstacles
                new rectObs(150, 0, 100, 600),

                //level interactables
                // new rectLand(510, 270, 60, 60),
                new rectLand(50, 270, 60, 60),
                new Portal (380, 300, 200, 11, 300, 300)
            ]

            scene10 = new Scene(560, 560, []);
            scene10.obstacles = [
                //boundary
                new rectObs(0, 0, 5, 250),
                new rectObs(0, 350, 5, 250),
                new rectObs(0, 0, 600, 5),
                new rectObs(0, 595, 600, 5),
                new rectObs(595, 0, 5, 600),
                new rectPortal(-10, 250, 5, 100, 9, 570, 300),

                //center obstacles
                new rectObs(70, 80, 20, 450),
                new rectObs(140, 80, 20, 180),
                new rectObs(140, 350, 20, 245),
                new rectObs(210, 5, 20, 255),
                new rectObs(210, 350, 20, 180),
                new rectObs(280, 80, 20, 180),
                new rectObs(280, 350, 20, 180),
                new rectObs(370, 100, 40, 150),
                new rectObs(370, 350, 40, 150),
                new rectObs(480, 100, 40, 150),
                new rectObs(480, 350, 40, 150),

                new rectObs(5, 80, 65, 20),
                new rectObs(240, 270, 30, 80),
                // modal filters lol
                new rectObs(410, 100, 20, 10),
                new rectObs(460, 100, 20, 10),
                new rectObs(300, 400, 20, 10),
                new rectObs(350, 400, 20, 10),

                new rectObs(160, 250, 50, 10),
                new rectObs(160, 350, 50, 10),

                //moving obstacles
                new movingObs1(50, 40, 30, 2.1, 0, 350, 50),
                new movingObs1(50, 560, 30, 1.9, 0, 350, 50), 
                new movingRectObs(20, 265, 10, 80, 2.5, 0, 550, 300),
                new movingRectObs(530, 100, 60, 10, 0, -3, 530, 500),
                new movingRectObs(415, 120, 60, 10, 0, -2, 415, 500),

                new movingObs1(305, 75, 15, 1, 0.5, 365, 260),
                new movingObs1(20, 130, 15, 2, 1, 120, 470),
                //interactables
                new sizeShift(445, 120, 15, 15, 2),
                new Portal(185, 220, 20, 10, 185, 400),
                new Portal(185, 380, 20, 10, 185, 200),
                
                new rectLand(95, 80, 40, 40),
                new rectLand(420, 520, 50, 50),
                new rectLand(420, 280, 50, 50),
                new rectLand(420, 30, 50, 50)
            ]

            scene11 = new Scene(300, 300, []);
            textSize(32);
            scene11.words = 'You have achieved happiness';

            scene11.obstacles[
                //boundary 
                new rectObs(0, 0, 5, 250),
                new rectObs(0, 350, 5, 250),
                new rectObs(0, 0, 600, 5),
                new rectObs(0, 595, 600, 5),
                new rectObs(595, 0, 5, 600)
            ];

            scenes = [scene1, scene2, scene3, scene4, scene5, scene6, scene7, scene8, scene9, scene10, scene11];
            
            console.log("Setup complete - scenes created");
        }

        // Baneling class
        class Baneling {
            constructor(x, y, size, speed) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.speed = speed;
                this.dire = createVector(0, 0);
                this.direTarget = createVector(0,0);
                this.angularAcc = 0.1;
                this.angle = 0;
            }

            draw() {
                /* this.y = constrain(this.y, 0, height);
                this.x = constrain(this.x, 0, width); */ 
                fill(186, 19, 242);
                ellipse(this.x, this.y, this.size, this.size);
            }

            direction() {
                let current = createVector(this.x, this.y);
                let click = createVector(mouseX, mouseY);
                click.sub(current);
                click.normalize();
                this.direTarget = click;
                console.log(this.direTarget);
            }
            
            // trying to create that angular acceleration feeling
            acc(){
                this.angle = (this.dire).angleBetween(this.direTarget);
                
                //From stationary
                if (this.dire.x == 0 && this.dire.y == 0 ) {
                    this.dire = this.direTarget;
                }
                // Zone 1
                else if (this.angle < -1/100 && this.angle > - 3 * PI / 4) {
                    let perpendicular = createVector (this.dire.y, -this.dire.x);
                    perpendicular.mult(this.angularAcc);
                    this.dire = p5.Vector.add(this.dire, perpendicular)
                    this.dire.normalize();
                }

                // Zone 3
                else if (1/100 < this.angle && this.angle < 3 * PI / 4){
                    let perpendicular = createVector (-this.dire.y, this.dire.x);
                    perpendicular.mult(this.angularAcc);
                    this.dire = p5.Vector.add(this.dire, perpendicular)
                    this.dire.normalize();
                }

                // Zone 2
                else {
                    this.dire = this.direTarget; 
                }
                
            }

            move() {

                // Ice terrain
                if (terrainType === 1) {
                    bane.acc();   
                    this.x += this.dire.x * this.speed;
                    this.y += this.dire.y * this.speed;
                } 
                // Land terrain
                else if (terrainType === 2) {
                     if (abs(lastClick.x - this.x) < 1.5 && abs(lastClick.y - this.y) < 1.5) {
                        this.dire = createVector(0, 0);
                    } else {
                        bane.dire = bane.direTarget;
                        this.x += this.dire.x * this.speed / 2;
                        this.y += this.dire.y * this.speed / 2;    
                    }
                }
            }
        }

        // Obstacle parent class
        class gameObj {
            constructor(x, y, size) {
                this.x = x; 
                this.y = y;
                this.size = size; 
            }

            check(bane) {
                if (dist(this.x, this.y, bane.x, bane.y) < bane.size/2 + this.size / 2) {
                    return true; 
                } else {
                    return false;
                }
            }

            draw() {
                ellipse(this.x, this.y, this.size, this.size);
            }
        }
        
        // Size changer
        class sizeShift extends gameObj{
            constructor(x, y, size, shift, speed){
                super(x, y, size);
                this.shift = shift;
                this.speed = speed; 
            }
        
            collision(bane) {
                if (this.check(bane)) {
                    bane.size = this.shift;
                    bane.speed = this.speed;
                    scenes[sceneCounter - 1].x = this.x;
                    scenes[sceneCounter - 1].y = this.y; 
                    
                }
            }
            
            draw() {
                fill(177, 156, 217);
                ellipse(this.x, this.y, this.size, this.size);
            }
            
        }

        // Rectangular Obstacle
        class rectObj extends gameObj {
            constructor(x, y, w, h){
                super(x,y);
                this.w = w;
                this.h = h;
            }

            draw() {
                rect(this.x, this.y, this.w, this.h);
            }
            
            check(bane) {
                return (
                        (bane.y + (bane.size /2)> this.y && 
                        bane.y - (bane.size /2) < this.y + this.h && 
                        bane.x > this.x && 
                        bane.x < this.x + this.w) || 
                        (bane.x + (bane.size /2) > this.x && 
                        bane.x - (bane.size /2) < this.x + this.w && 
                        bane.y > this.y && 
                        bane.y < this.y + this.h) ||
                        (dist(bane.x, bane.y, this.x, this.y) < bane.size / 2)||
                        (dist(bane.x, bane.y, this.x + this.w, this.y) < bane.size / 2)||
                        (dist(bane.x, bane.y, this.x, this.y + this.h) < bane.size / 2)||
                        (dist(bane.x, bane.y, this.x + this.w, this.y + this.h) < bane.size / 2)
            )
            }
        }
        
        class movingRectObj extends rectObj{
            constructor(x, y, w, h, xVel, yVel, x1, y1){
                super(x,y,w,h);
                this.x0 = x;
                this.y0 = y;
                this.x1 = x1;
                this.y1 = y1;
                this.xVel = xVel;
                this.yVel = yVel;
                this.vel = createVector (this.xVel, this.yVel);
                
            }
            
            draw(){
                super.draw(); 
                this.x = this.x + this.vel.x;
                this.y = this.y + this.vel.y;

                // moving objects will "bounce" off of walls
                if(this.x > this.x1 || this.x < this.x0){
                    this.vel.x = -this.vel.x;
                }
                if(this.y > this.y1 || this.y < this.y0){
                    this.vel.y = -this.vel.y;
                }
            }
        }

        class movingRectObs extends movingRectObj{
            collision(bane) {
                if (this.check(bane)) {
                    collide = true; 
                    bane.direTarget = bane.dire;
                    deathCounter++;
                }
            }

            draw(){
                fill(189, 0, 0);
                super.draw();
            }
        }

        class rectPortal extends rectObj{
            constructor(x, y, w, h, c, x1, y1){
                super(x,y,w,h);
                this.c = c;
                this.x1 = x1;
                this.y1 = y1;
            }
            draw(){
                fill (38,139,7);
                super.draw(); 
            }
            collision(bane) {
                if (this.check(bane)) {
                    portalBool = true;
                    sceneCounter = this.c;
                    scenes[sceneCounter - 1].x = this.x1;
                    scenes[sceneCounter - 1].y = this.y1;
                    collide = true;
                }
            }
        }

        // Land terrain
        class Land extends gameObj {
            collision(bane) {
                if (this.check(bane)) {
                    terrainType = 2;
                }
            }

            draw() {
                fill(247, 255, 0);
                super.draw();
            }
        }

        // Basic obstacle
        class basicObs extends gameObj {
            draw() {
                fill(189, 0, 0);
                super.draw();
            }

            collision() {
                if (this.check(bane)) {
                    collide = true; 
                    bane.direTarget = bane.dire;
                    deathCounter++;
                }
            }
        }

        // Moving basic obstacle
        class movingObs extends basicObs{
            constructor(x, y, size, xVel, yVel){
                super(x, y, size);
                this.xVel = xVel;
                this.yVel = yVel;
                this.vel = createVector (this.xVel, this.yVel);
            }
            
            draw(){
                super.draw(); 
                this.x = this.x + this.vel.x;
                this.y = this.y + this.vel.y;

                // moving objects will "bounce" off of walls
                if(this.x > 600 || this.x < 0){
                    this.vel.x = -this.vel.x;
                }
                if(this.y > 600 || this.y < 0){
                    this.vel.y = -this.vel.y;
                }
            }
        }

        class movingObs1 extends basicObs{
            constructor(x, y, size, xVel, yVel, x1, y1){
                super(x, y, size);
                this.xVel = xVel;
                this.yVel = yVel;
                this.x1 = x1;
                this.y1 = y1;
                this.x0 = x;
                this.y0 = y;
                this.vel = createVector (this.xVel, this.yVel);
            }
            
            draw(){
                super.draw();
                this.x = this.x + this.vel.x;
                this.y = this.y + this.vel.y;

                // moving objects will "bounce" off of walls
                if(this.x > this.x1 || this.x < this.x0){
                    this.vel.x = -this.vel.x;
                }
                if(this.y > this.y1 || this.y < this.y0){
                    this.vel.y = -this.vel.y;
                }
            }
        }

        class repel extends movingObs{
            acc(){
                let x = scenes[sceneCounter - 1].obstacles;
                for (var i = 0; i < x.length; i++){
                    if (x[i] instanceof repel && (x[i] != this)){
                        let distance = dist(this.x, this.y, x[i].x, x[i].y);
                        // Prevent division by zero with minimum distance
                        distance = max(distance, 15);
                        let measure = (1 / (distance ** 2));
                        let gravConstant = 150;
                        let direction = createVector(-x[i].x + this.x, -x[i].y + this.y);
                        direction.normalize();
                        this.vel.add(p5.Vector.mult(direction, gravConstant * measure))
                    }
                }
            }
            
            draw(){
                super.draw();
                this.acc(); 
            }
        }

        class planet extends movingObs{
            acc(){
                let x = scenes[sceneCounter - 1].obstacles;
                for (var i = 0; i < x.length; i++){
                    if (x[i] instanceof planet && (x[i] != this)){
                        let distance = dist(this.x, this.y, x[i].x, x[i].y);
                        // Prevent division by zero with minimum distance
                        distance = max(distance, 15);
                        let measure = (1 / (distance ** 2));
                        let gravConstant = 150;
                        let direction = createVector(x[i].x - this.x, x[i].y - this.y);
                        direction.normalize();
                        this.vel.add(p5.Vector.mult(direction, gravConstant * measure))
                    }
                }
            }
            
            draw(){
                super.draw();
                this.acc(); 
            }
        }

        // Rectangular Land
        class rectLand extends rectObj {
            draw() {
                fill(247, 255, 0);
                super.draw();
            }

            collision(bane) {
                if (this.check(bane)) {
                    terrainType = 2;

                }
            }
        }

        // Rectangular Obstacle
        class rectObs extends rectObj {
            constructor(x, y, w, h){
                super(x,y,w,h);
            }

            collision() {
                if (this.check(bane)) {
                    collide = true; 
                    bane.direTarget = bane.dire;
                    deathCounter++;
                }
            }

            draw(){
                fill(255,69,0);
                super.draw();
            }
        }

        // Portal
        class Portal extends gameObj {
            constructor(x, y, size, c, x1, y1) {
                super(x, y, size);
                this.c = c;
                this.x1 = x1;
                this.y1 = y1;
            }

            collision(bane) {
                if (this.check(bane)) {
                    sceneCounter = this.c;
                    scenes[this.c - 1].x = this.x1;
                    scenes[this.c - 1].y = this.y1;
                    collide = true;
                    portalBool = true;
                }
            }

            draw() {
                fill (38,139,7);
                super.draw();
            }
        }

        class planetol extends repel{
            constructor(x, y, size, xVel, yVel, c){
                super(x, y, size, xVel, yVel);
                this.c = c;
            }
            collision(bane) {
                if (this.check(bane)) {
                    sceneCounter = this.c;
                    collide = true;
                }
            }
            draw() {
                fill(38, 139, 7);  // Green color
                ellipse(this.x, this.y, this.size, this.size);  // Draw the circle
                this.acc();  // Call the physics method from repel class
                
                // Handle movement and boundary bouncing
                this.x = this.x + this.vel.x;
                this.y = this.y + this.vel.y;
                
                if(this.x > 600 || this.x < 0){
                    this.vel.x = -this.vel.x;
                }
                if(this.y > 600 || this.y < 0){
                    this.vel.y = -this.vel.y;
                }
    }

        }

        // Scene class
        class Scene {
            constructor(x, y, obstacles) {
                this.x = x;
                this.y = y; 
                this.obstacles = obstacles || [];
                this.words = '';
            }

            reset(bool) {
                if (bool === true) {
                    bane.x = this.x;
                    bane.y = this.y;

                    if (portalBool == true){
                        portalBool = false;
                    }
                    else {
                    bane.dire.x = 0;
                    bane.dire.y = 0; 
                    }
                collide = false;
                }
            }

            draw(baneling) {
                for (let i = 0; i < this.obstacles.length; i++) {
                    this.obstacles[i].draw(); 
                    this.obstacles[i].collision(baneling);
                }
                fill(0, 0 , 0);
                text(this.words, 100, 200);
            }
        }

        function mousePressed() {
            bane.direction();
            fill(0, 255, 34);
            ellipse(mouseX, mouseY, 30, 30);
            lastClick.x = mouseX;
            lastClick.y = mouseY;
        }

        function updateUI() {
            document.getElementById('deathCounter').textContent = deathCounter;
            document.getElementById('sceneDisplay').textContent = sceneCounter;
            document.getElementById('terrainDisplay').textContent = terrainType === 1 ? 'Ice' : 'Land';
        }

        function draw() {
            // background color
            background(203, 241, 250);
            terrainType = 1;
            
            scenes[sceneCounter - 1].reset(collide);
            scenes[sceneCounter - 1].draw(bane);

            bane.move();
            bane.draw();
            
            updateUI();
        }
    </script>
</body>
</html>



